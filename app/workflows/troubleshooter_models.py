"""Models for the troubleshooting workflow.

This module contains Pydantic models for the two-invocation troubleshooting
workflow:

Invocation 1 (intake):
    START -> intake_parse -> retrieve_docs -> assess_risk -> generate_followups -> END
                                                          -> safety_stop -> END

Invocation 2 (diagnosis):
    START -> generate_diagnosis -> render_output -> END

Models are organized into:
- Enums and small value objects (FollowupQuestion, FollowupAnswer, DiagnosticStep)
- Instructor response models (FollowupGenerationResponse, DiagnosisResponse)
- Workflow state (TroubleshootingState)
- API request/response models
"""

from enum import Enum

from pydantic import BaseModel, Field

from app.rag.models import RiskLevel
from app.workflows.models import HouseProfile, RetrievedChunk

# =============================================================================
# ENUMS
# =============================================================================


class QuestionType(str, Enum):
    """Types of follow-up questions the LLM can generate."""

    YES_NO = "yes_no"
    MULTIPLE_CHOICE = "multiple_choice"
    FREE_TEXT = "free_text"


class TroubleshootPhase(str, Enum):
    """Tracks which phase the troubleshooting session is in."""

    INTAKE = "intake"
    FOLLOWUP = "followup"
    DIAGNOSIS = "diagnosis"
    SAFETY_STOP = "safety_stop"
    COMPLETE = "complete"


# =============================================================================
# FOLLOW-UP QUESTION MODELS
# =============================================================================


class FollowupQuestion(BaseModel):
    """A follow-up question generated by the LLM to narrow down diagnosis.

    Example:
        {
            "id": "q1",
            "question": "Is the pilot light visible on your furnace?",
            "question_type": "yes_no",
            "options": null,
            "why": "Determines if the ignition system is the issue"
        }
    """

    id: str = Field(description="Unique identifier for this question (e.g., 'q1')")
    question: str = Field(description="The follow-up question to ask the user")
    question_type: QuestionType = Field(description="Type of answer expected")
    options: list[str] | None = Field(
        default=None,
        description="Options for multiple_choice questions",
    )
    why: str = Field(
        description="Brief explanation of why this question helps narrow diagnosis",
    )


class FollowupAnswer(BaseModel):
    """A user's answer to a follow-up question.

    Example:
        {
            "question_id": "q1",
            "answer": "No, the pilot light is not visible"
        }
    """

    question_id: str = Field(description="ID of the question being answered")
    answer: str = Field(description="The user's answer")


# =============================================================================
# DIAGNOSTIC STEP MODEL
# =============================================================================


class DiagnosticStep(BaseModel):
    """A single step in the diagnostic procedure.

    Example:
        {
            "step_number": 1,
            "instruction": "Check that the thermostat is set to HEAT mode",
            "expected_outcome": "Display shows HEAT and set temperature",
            "if_not_resolved": "Move to step 2",
            "risk_level": "LOW",
            "source_doc": "Furnace-OM9GFRC-02.pdf",
            "requires_professional": false
        }
    """

    step_number: int = Field(description="Sequential step number")
    instruction: str = Field(description="What the user should do")
    expected_outcome: str = Field(description="What should happen if this step resolves it")
    if_not_resolved: str = Field(description="Guidance if this step doesn't fix the issue")
    risk_level: RiskLevel = Field(description="Risk level for this specific step")
    source_doc: str | None = Field(
        default=None,
        description="Source document supporting this step",
    )
    requires_professional: bool = Field(
        default=False,
        description="Whether this step requires a licensed professional",
    )


# =============================================================================
# INSTRUCTOR RESPONSE MODELS
# =============================================================================


class FollowupGenerationResponse(BaseModel):
    """Structured LLM response for generating follow-up questions.

    Used with instructor to get reliable structured output from the LLM.
    """

    risk_level: RiskLevel = Field(
        description="Assessed risk level based on symptom and device type",
    )
    followup_questions: list[FollowupQuestion] = Field(
        description="2-3 targeted follow-up questions to narrow diagnosis",
    )
    safety_concerns: str | None = Field(
        default=None,
        description="Any safety concerns identified (even if not safety-stop level)",
    )
    preliminary_assessment: str = Field(
        description="Brief initial assessment based on reported symptom",
    )


class DiagnosisResponse(BaseModel):
    """Structured LLM response for generating a diagnosis.

    Used with instructor for the second invocation (after follow-ups).
    """

    diagnosis_summary: str = Field(
        description="Brief summary of the likely issue and root cause",
    )
    diagnostic_steps: list[DiagnosticStep] = Field(
        description="Ordered steps to diagnose and resolve the issue (3-6 steps)",
    )
    overall_risk_level: RiskLevel = Field(
        description="Overall risk level for the troubleshooting procedure",
    )
    when_to_call_professional: str = Field(
        description="Clear guidance on when to stop DIY and call a professional",
    )


# =============================================================================
# WORKFLOW STATE
# =============================================================================


class TroubleshootingState(BaseModel):
    """State that flows through the troubleshooting workflow.

    This model holds all data across both invocations:
    - Invocation 1 sets: device_type, symptom, urgency, context,
      house_profile, retrieved_chunks, risk assessment, follow-up questions
    - Session storage persists state between invocations
    - Invocation 2 adds: followup_answers, diagnostic output

    All fields have defaults so nodes can return partial updates.
    """

    # --- Intake inputs ---
    device_type: str | None = Field(
        default=None,
        description="The type of device with the issue (e.g., 'furnace')",
    )
    symptom: str | None = Field(
        default=None,
        description="User-reported symptom or problem description",
    )
    urgency: str | None = Field(
        default=None,
        description="How urgent: 'low', 'medium', 'high', 'emergency'",
    )
    additional_context: str | None = Field(
        default=None,
        description="Any additional context the user provides",
    )
    house_profile: HouseProfile | None = Field(
        default=None,
        description="The house profile with installed systems",
    )

    # --- Retrieval ---
    retrieved_chunks: list[RetrievedChunk] = Field(
        default_factory=list,
        description="Chunks retrieved from RAG index",
    )

    # --- Risk assessment ---
    risk_level: RiskLevel | None = Field(
        default=None,
        description="Assessed risk level",
    )
    is_safety_stop: bool = Field(
        default=False,
        description="Whether the workflow should stop for safety reasons",
    )
    safety_message: str | None = Field(
        default=None,
        description="Safety message if safety_stop triggered",
    )
    recommended_professional: str | None = Field(
        default=None,
        description="Type of professional to call (e.g., 'licensed gas technician')",
    )

    # --- Follow-up Q&A ---
    followup_questions: list[FollowupQuestion] = Field(
        default_factory=list,
        description="Generated follow-up questions",
    )
    followup_answers: list[FollowupAnswer] = Field(
        default_factory=list,
        description="User's answers to follow-up questions",
    )
    preliminary_assessment: str | None = Field(
        default=None,
        description="Initial assessment from the LLM",
    )

    # --- Diagnostic output ---
    diagnosis_summary: str | None = Field(
        default=None,
        description="Summary of the diagnosis",
    )
    diagnostic_steps: list[DiagnosticStep] = Field(
        default_factory=list,
        description="Ordered diagnostic/resolution steps",
    )
    overall_risk_level: RiskLevel | None = Field(
        default=None,
        description="Overall risk level for the diagnosis",
    )
    when_to_call_professional: str | None = Field(
        default=None,
        description="Guidance on when to call a professional",
    )
    markdown_output: str | None = Field(
        default=None,
        description="Final markdown-formatted diagnostic output",
    )

    # --- Phase tracking ---
    phase: TroubleshootPhase = Field(
        default=TroubleshootPhase.INTAKE,
        description="Current phase of the troubleshooting workflow",
    )
    session_id: str | None = Field(
        default=None,
        description="Session ID for correlating invocations",
    )
    error: str | None = Field(
        default=None,
        description="Error message if something failed",
    )


# =============================================================================
# API REQUEST/RESPONSE MODELS
# =============================================================================


class TroubleshootStartRequest(BaseModel):
    """API request to start a troubleshooting session.

    This kicks off Invocation 1 (intake graph).
    """

    device_type: str = Field(
        description="Device with the issue (e.g., 'furnace', 'water_heater')",
    )
    symptom: str = Field(
        description="Description of the problem or symptom",
    )
    urgency: str = Field(
        default="medium",
        description="Urgency level: 'low', 'medium', 'high', 'emergency'",
    )
    additional_context: str | None = Field(
        default=None,
        description="Any additional context (when it started, what changed, etc.)",
    )


class TroubleshootStartResponse(BaseModel):
    """API response from starting a troubleshooting session.

    Returns either follow-up questions or a safety stop.
    """

    session_id: str = Field(description="Session ID for the follow-up request")
    phase: TroubleshootPhase = Field(description="Current phase after intake")
    risk_level: RiskLevel = Field(description="Assessed risk level")

    # Follow-up path
    followup_questions: list[FollowupQuestion] = Field(
        default_factory=list,
        description="Questions for the user (empty if safety_stop)",
    )
    preliminary_assessment: str | None = Field(
        default=None,
        description="Initial assessment of the issue",
    )

    # Safety stop path
    is_safety_stop: bool = Field(
        default=False,
        description="Whether the workflow stopped for safety",
    )
    safety_message: str | None = Field(
        default=None,
        description="Safety message if stopped",
    )
    recommended_professional: str | None = Field(
        default=None,
        description="Professional to call if safety stop",
    )


class TroubleshootDiagnoseRequest(BaseModel):
    """API request to submit follow-up answers and get diagnosis.

    This kicks off Invocation 2 (diagnosis graph).
    """

    session_id: str = Field(description="Session ID from the start response")
    answers: list[FollowupAnswer] = Field(
        description="User's answers to the follow-up questions",
    )


class TroubleshootDiagnoseResponse(BaseModel):
    """API response with the full diagnosis.

    Contains diagnostic steps, risk assessment, and formatted output.
    """

    session_id: str = Field(description="Session ID for reference")
    diagnosis_summary: str = Field(description="Summary of the likely issue")
    diagnostic_steps: list[DiagnosticStep] = Field(
        description="Ordered steps to resolve the issue",
    )
    overall_risk_level: RiskLevel = Field(
        description="Overall risk level for the procedure",
    )
    when_to_call_professional: str = Field(
        description="When to stop DIY and call a professional",
    )
    markdown: str = Field(
        description="Formatted markdown output for display/export",
    )
    sources_used: list[str] = Field(
        default_factory=list,
        description="Source documents that informed the diagnosis",
    )
